use Forks::Super ':test_CA';
use Test::More tests => 21;
use strict;
use warnings;

#
# test that background jobs send a SIGCHLD to the parent when
# they complete and that the signal is handled by the parent.
# Jobs stay in the "COMPLETE" state until they are waited on
# with Forks::Super::wait or Forks::waitpid. Then the job changes to
# the "REAPED" status.
#

our $_LOCK = 0;  # use same synchronization technique as F::S::Sigchld

sub child_signal_hijacker {
# $SIGNAL::TIME = Time::HiRes::gettimeofday() if $_[0] =~ /^C/;
  $_LOCK++;
  if ($_LOCK>1) {
    $_LOCK--;
    return;
  }

  my %complete;
  for my $cj (grep { $_->is_complete } @Forks::Super::ALL_JOBS) {
    $complete{$cj}++;
  }
  Forks::Super::Sigchld::handle_CHLD(@_);

  for my $cj (grep { $_->{state} eq "COMPLETE" } @Forks::Super::ALL_JOBS) {
    unless (delete $complete{$cj}) {
      #print "NEW COMPLETE JOB: ", $cj->toString(), "\n";
      $LAST::COMPLETE = $cj;
      $LAST::COMPLETE{$cj}++;
      $SIGNAL::TIME = Time::HiRes::gettimeofday();
    }
  }
  $_LOCK--;
  return;
}

##################################################################

my $old_sig_chld = delete $SIG{CHLD};
$SIG{CHLD} = \&child_signal_hijacker;
*Forks::Super::handle_CHLD = *child_signal_hijacker;
$SIGNAL::TIME = Time::HiRes::gettimeofday();

my $pid = fork();
if (defined $pid && $pid == 0) {
  sleep 2;
  exit 0;
}
ok(defined $pid && isValidPid($pid), "$$\\valid pid $pid");
my $j = Forks::Super::Job::get($pid);
ok($j->{state} eq "ACTIVE", "active state");

# sometimes one SIGCHLD isn't enough to force a system call interruption.
# let's set up a couple more processes to send SIGCHLD
#for my $n (3,4,5,6) {
#  my $pidn = fork();
#  if (defined $pidn && $pidn == 0) {
#    sleep $n;
#    exit 0;
#  }
#}

# Perl's sleep can _sometimes_ be interrupted by SIGCHLD.
# This never happens on Windows, which doesn't have a 
# But I've also seen it not happen intermittently
# on FreeBSD and CentOS :-(

my $t = Time::HiRes::gettimeofday();
SKIP: {
  if ($^O eq "MSWin32") {
    Forks::Super::pause(5);
    skip "sleep call not interrupted on $^O", 2;
  }
  local $! = 0;
  sleep 10;   # sleep should be interrupted by SIGCHLD
  $t = Time::HiRes::gettimeofday() - $t;

  #if ($t > 9) {
  #  Forks::Super::pause();
  #  skip "No interruption to sleep on $^O.", 1;
  #}
  ok($t <= 5.05, "Perl sleep interrupted by CHLD signal ${t}s");
  ok($! =~ /Interrupted/, "\$! indicates interrupted system call $!");
  Forks::Super::pause();
}
ok($j->{state} eq "COMPLETE", "job state is COMPLETE");
SKIP: {
  skip "No implicit SIGCHLD handling on Win32", 3 if $^O eq 'MSWin32';

  # XXXXXX - pass test (1) and fail test (2) would be ok
  ok(defined $LAST::COMPLETE{$j}, 
     "job caught in SIGCHLD handler/$j/" . $j->{pid}); ### 5 ###
  ok($LAST::COMPLETE eq $j, 
     "job caught in SIGCHLD handler/$LAST::COMPLETE/"
    . $LAST::COMPLETE->{pid});                         ### 6 ###
  my $tt = $SIGNAL::TIME - $j->{end};
  ok(abs($tt) < 2, "short delay ${tt}s in SIGCHLD HANDLER expected <2s");
}
sleep 1;
my $p = wait;
ok($pid == $p, "wait reaped correct process");
ok($j->{state} eq "REAPED", "reaped process has REAPED state");
ok($j->{reaped} - $j->{end} > 0, "reap occurred after job completed");
#print $j->toString();
%LAST::COMPLETE = ();

#######################################################

# try  Forks::Super::pause  for uninterruptible sleep

$pid = fork();
if (defined $pid && $pid == 0) {
  sleep 2;
  exit 0;
}
ok(defined $pid && isValidPid($pid), "valid pid $pid");
$j = Forks::Super::Job::get($pid);
ok($j->{state} eq "ACTIVE", "active state");
$t = Time::HiRes::gettimeofday();
Forks::Super::pause(6);   # ACK! sleep can be interrupted by CHLD signal!
$t = Time::HiRes::gettimeofday() - $t;
ok($t > 5.7 && $t < 7.75,                           ### 13 ### was 7.1 obs 7.10
   "Forks::Super::pause(6) took ${t}s expected 6");
ok($j->{state} eq 'COMPLETE', "complete state " . $j->{state});
SKIP: {
  skip "No implicit SIGCHLD handling on Win32", 3 if $^O eq 'MSWin32';

  # XXXXXX pass test (1) and fail test (2) would be ok
  ok(defined $LAST::COMPLETE{$j}, 
     "job in SIGCHLD handler/$j/" . $j->{pid});    ### 15 ###
  ok($LAST::COMPLETE eq $j,
     "job in SIGCHLD handler/$LAST::COMPLETE/"
     . $LAST::COMPLETE->{pid});                    ### 16 ###
  my $tt = $SIGNAL::TIME - $j->{end};
  ok(abs($tt) < 2, "short delay ${tt}s in SIGCHLD handler, expected <2s");
}
$p = wait;
ok($pid == $p, "wait reaped correct job");
ok($j->{state} eq "REAPED", "job state changed to REAPED in wait");
my $tt = $j->{reaped} - $j->{end};
ok($tt > 1, 
   "reaped at $j->{reaped}, ended at $j->{end} ${tt}s expected >1s");
if ($tt <= 1) {
  print STDERR "Job created at $j->{created}\n";
  print STDERR "Job started at $j->{start}\n";
  print STDERR "Job ended at $j->{end}\n";
  print STDERR "Job reaped at $j->{reaped}\n";
}
