Thoughts about future releases, in no particular order.
Feel free to share your thoughts with me at  mob@cpan.org .

Possible TODOs:

    ___ incorporate free memory into system busy-ness calc 
		(Parallel::ForkControl)	(Parallel::ForkControl says 
		"non functional")

    _X_ implement child handles through pipe objects
	___ use IO::Pipe
	_X_ document, extend file vs. socket discussion
	    On MSWin32, for example, pipe capacity is 512 bytes?

    _x_ support sockets/pipes for cmd-style forks like IPC::Open3 does.
	_X_ for Unixy systems
	___ for MSWin32

    ___ Support for launching tasks on remote hosts (maybe that's beyond
        the scope of this module) See Paralell::PVM?

    ___	Forks::Super::Uninterruptable package for "uninterruptable" versions
	of Perl system calls like  sleep , connect , select($$$$). Well,
        for interruption-resistant versions, anyway.

    ___ Make Forks::Super safe(r) for unsafe signals (pre 5.7.3, see perlipc).
	Can test with  PERL_SIGNALS=unsafe make test .

    _x_	Make CONFIG{filehandles} meaningful. If we set CONFIG{filehandles}=0,
	then all IPC should be through sockets or pipes.
	___ Document? Come up with a better way to set this feature?

    ___ There's enough stuff in here now that performance is affected,
	especially when there are lots of short tasks. What can be done
	to tighten up performance? What can be done to reduce overhead
	when there are many short tasks?

        Characterize some use cases for Forks::Super, and use settings
        appropriate to that use case. For example, if we use Forks::Super
        to manage many short tasks, we want to run the queue frequently
	and we want to use a short pause time. If we use Forks::Super to
	manage long, CPU-intense tasks, then frequent queue checks and
        brief pauses will make the Forks::Super module use up CPU that
	could be going to the tasks.

        ___ $FSU::DEFAULT_PAUSE short when tasks are quick,
            long when there are a lot of tasks
        ___ $FSQ::QUEUE_MONITOR_FREQ short when tasks are quick
        ___ $FSQ::QUEUE_MONITOR_LIFESPAN long or infinite for "daemon" programs
        ___ $FS::SOCKET_READ_TIMEOUT short for quick tasks
	___ $FS::MAX_PROC and ::DEFAULT_PROC to 1-1.5 times the number of
	    CPUs for CPU-intensive tasks; higher for IO bound tasks;
	    much higher for tasks with ample idle time

	Also document tips and tricks for tuning performance.
	Things like "Set $Forks::Super::Util::DEFAULT_PAUSE to
	a small value when you have lots of short tasks, and
	longer for longer tasks".

    ___ Test needed, Win32+cmd, See Job.pm:344 (404?) 
        (FSJO::Win32::openX_win32_process?)

    _x_ With cmd and child_fh => "in" where cmd has pipes (cmd1 | cmd2),
	'<.fhfork/.fh_xxx' needs to go _before_ the first pipe
	_X_ solve basic case
	___ solve complicated case, where first pipe char might be a
	    quoted argument, or part of an argument.
	    e.g., what if the external command is
		perl -F/\\\|/ -ane 'BLOCK' < .fhforkXXX/.fh_XXX | ./other_prog

    ___ fork { run => [ \@cmd, ... ] }
	to invoke or emulate IPC::Run's rich feature set
	___ What else can I learn by studying IPC::Run?

    _X_ More tests from a child process and see what breaks.
		use Forks::Super;
		CORE::fork() && exit;
		# now $$ != $MAIN_PID but this is the
		# "parent" process of Forks::Super.
		do_something_and_see_if_it_works();
        _X_ works good. MAIN_PID doesn't get initialized until fork() call

    _o_ Investigate "filehandle leaks" in t/forked_harness.pl.

    ___ Tie scalar in parent to read end of a pipe? As child
	writes to the pipe, the scalar can be updated in
	the parent?

	Use case is  fork { stdout => $output }, and to be able
	to read/use intermediate $output values without having to
	wait for the child to finish.

	Prototype in spike-pipe-tie2.pl

	___ scalar is associated with a read handle and the job
	___ add scalar to a global list/set of pipes to read from
	___ on FETCH and during productive pauses, pull the most recent output
	___ on close in the parent, optionally kill the child process,
		close both the read and write ends of the filehandle

    _o_ Tie all filehandles from _safeopen for improved debugging
	in Forks::Super::Job::IPC. 
	_x_ we are piling a lot of handle data into the symbol table now

    ___ block attribute or block value in child_fh attribute to
	indicate whether blocking I/O is desired.

    ___ What other key-value pairs should FSJ::read_stdxxx handle?
	_X_ warn => 0|1

    _o_ fork { input_fh => [ 'X', 'Y', 'Z' ], output_fh => [ 'STDOUT', 'A' ] }

		open input and output filehandles in the child with the given 
		names, accessible in the parent at something like 
		$Forks::Super::CHILD_FH{$pid}{X}

	Plans for Forks::Super::IPCChannel in 1.0 should handle this.

    ___ what else to configure at build time?
	___ e.g. "has Unixy signal framework"
	___ "is Windows"
	___ "is Windows/Cygwin"
	___ we can spoof this information for some tests ...
	___ signal list? trappable? "available"?

    ___ Reimplement gensym() in Forks::Super::Job::Ipc to use
	safer 'Forks::Super::Symbol' package ?

    _X_ Forks::Super::Util::Time() is redundant. Replace with
	Time::HiRes::gettimeofday().

    ___ Support bg_qx on systems where YAML::Tiny is installed
	without YAML.

    _X_ Use Carp::Always in unit tests (if available). Um, but don't
	ALWAYS use it.

    _X_ Reimplement F::S::Tie::BackgroundScalar to not require
	dereferencing. Say, by using overloading.

    ___ Hijack sleep function with FSU::pause or F::S::Uninterruptable::sleep?

    ___ Turn installation of bundled packages on by default for a couple
	of CPAN testing cycles. See what breaks.

    ___ Keep the pipes clear:
        ___ During productive pauses, read and buffer input from all pipes
            connected to child process output streams. IO handles in the parent
	    are tied to some package that implements this functionality.

        ___ Harder: child processes have a subroutine to read and buffer
	    input from piped STDIN, and an out-of-the-way signal handler
	    to invoke the subroutine. During productive pauses in the
	    parent process, signal the child processes to run these
	    subroutines.

    ___ The IPC module needs to create a temporary directory that will
        be deleted when the program ends. Is there another module that
        has solved this problem better than I did?

    ___ Runtime IPC cleanup routine for long running programs. For long
	completed jobs: close the open filehandles that have slipped
	through the cracks; remove the IPC files; move from 
	%ALL_JOBS,@ALL_JOBS to %ARCHIVED_JOBS,@ARCHIVED_JOBS

    ___ Is it possible/desirable to use threads in place of "queue
	monitor process", "productive pause"?

    _X_ Does Forks::Super work in taint mode? Need some tests to make
	sure.

	Can run t/forked_harness.pl with  -p -t  or  -p -T  options.

    _x_ Make Win32::API a required module for MSWin32.

    ___ http://www.cpantesters.org/cpan/report/8376777 -- are there
	issues with Forks::Super and $ENV{LANG} == 'zh_TW.UTF-8'?
	utf issues?

	_X_ Vanilla utf8 seems ok. Running  t/forked_harness.pl  with
	    -p -Mutf8  passes.

