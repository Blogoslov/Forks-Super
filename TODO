Thoughts about future releases, in no particular order.
Feel free to share your thoughts with me at  mob@cpan.org .

Possible TODOs:

	wait     timeout
        waitpid  timeout
        waitall  timeout

		wait calls that block for only a limited time
         
        fork { stdin => \@STDIN }

		pass standard input to the child in a list at fork time.
                This seems more satisfactory for a  cmd  style fork that
                possibly can't wait for the parent to write to 
        	Forks::Super::CHILD_STDIN{$pid}.

        fork { stdout => \@output, stderr => \@error }

                when the child process completes, collect its stdout and stderr
                output into the specified arrays. This will conserve filehandles
                in the parent.

        fork { input_fh => [ 'X', 'Y', 'Z' ], output_fh => [ 'STDOUT', 'A' ] }

		open input and output filehandles in the child with the given names,
		accessible in the parent at something like 
		$Forks::Super::filehandles{$pid}{X}

        incorporate CPU load into system busy-ness calc (see Parallel::ForkControl)

	incorporate free memory into system busy-ness calc (Parallel::ForkControl)

        implement child handles as sockets. May (or may not be) more robust
        than filehandles, or useful as backup when there are no more filehandles
	available

	implement child handles through IO::Pipe objects

        fork { callback => \&method }

                subroutine to call in the parent process when the child finishes

		callbacks for other events could also be considered:
			callback for a child starting
			callback for a child blocking
			callback for a child getting put on queue
			callback for a fatal error in child

        facilities to suspend jobs when the system gets to busy
        and to resume them when the system gets less busy.
        I bet this will be hard to do with Win32.

    _X_ fork { debug => $boolean }

        	override $Forks::Super::DEBUG for this job

    _x_ fork { cpu_affinity => $bitmask }

                <OLD POD>
                On supported systems with multiple cores, and after the successful
                creating of the child process, attempt to set the CPU affinity for
                the child process. $mask is typically a bitmask with the lowest level
                bits indicating whether the lowest numbered CPU's should be used
                by this process.
                </OLD POD>

                _X_ linux [where /bin/taskset is avail]
		_X_ MSWin32
		___ BSD
		_X_ Cygwin
		_X_ documented

    _X_ Currently USR1 is used to signal the program to analyze the queue.
        Make the signal configurable.

    _X_ Fully support changing process priority in Windows. This can be
	done with Win32::API and SetThreadPriority method. Takes on values
	between -2 and 2, or between -7 and 6 "if the thread has the
	REALTIME_PRIORITY_CLASS base class", whatever that is. (Oh, looks
	like we can use GetPriorityClass to figure out what it is).
        (See http://msdn.microsoft.com/en-us/library/ms686277(VS.85).aspx).

	Support for launching tasks on remote hosts (maybe that's beyond
        the scope of this module) See Paralell::PVM?

    _x_ fork { retries => $ntries }

		like Proc::Fork. Call CORE::fork() several times if
		it's not creating child processes.
		_X_ implement
		___ test
		___ document

	fork { name => $name }

		Change ps() listing as in Parallel::ForkControl, or give
		another way to lookup a job object from Forks::Super::Job::get.

    _X_ support some more configuration in import

                use Forks::Super MAX_PROC => 5, CHILD_FORK_OK => -1, ... ;
		_X_ MAX_PROC
		_X_ MAX_LOAD
		_X_ DEBUG
		_X_ ON_BUSY
		_X_ CHILD_FORK_OK
		_X_ QUEUE_MONITOR_FREQ
		_X_ FH_DIR
		_X_ unit tests for this kind of initialization

    ___ clean up temporary files. In some OS,
	     can't delete files from END block of parent if children
	     are still using those files. One possible solution might
             be to launch another background process that will try to
	     clean up for ~5 minutes

        _o_ haven't observed this problem lately

	configure during build. discover the maximum number of simultaneous
	processes that can be spawned and set MAX_PROC, DEFAULT_MAX_PROC.
	Would also be good to know the max number of open filehandles
	and plan around it.

	Forks::Super::Uninterruptable package for "uninterruptable" versions
	of Perl system calls like  sleep , connect , select($$$$)

    ___ Make Forks::Super safe(r) for unsafe signals (pre 5.7.3, see perlipc)